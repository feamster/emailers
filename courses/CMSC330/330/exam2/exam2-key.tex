\documentclass[11pt,fleqn]{article}

  %
  % After the grading has been going on a while doublecheck the TAs'
  % grading.
  %

  %
  % Should have added something to the grading key for most questions that
  % grading decisions should be written down on the grading sheet.
  %

  %
  % The final exam grading key has more detailed procedural instructions
  % after each question.
  %

  \usepackage{330-f12}

  \addtolength{\headsep}{-7mm}

  \addtolength{\textheight}{7mm}

  \showinfo

\begin{document}

  \header{\course}{Exam \#2 grading key}{\Term}

  {

    \setlength{\leftmargini}{5mm}

    \vspace*{-6mm}

    \begin{info}{\textbf{\underline{\Large Common grading criteria for all
                 parts}}}

      \vspace*{-2mm}

      \enlargethispage{6mm}

      \setlength{\leftmarginii}{5mm}

      \begin{enumerate}

        \addtolength{\itemsep}{.5mm}

        \item Be sure to first check that our answers are correct, that the
          grading criteria make sense, and that the point values add up
          right.

        \item Circle or mark \textbf{anything} that is incorrect.  You don't
              need to write the correct answers but students
              \textbf{\underline{must}} be able to tell what they are losing
              credit for (what was wrong or missing in their answer), and not
              have any points subtracted without being clear what the reason
              is.  Students will ask us about the grading, and we need to be
              able to tell why they lost points.

              If something is wrong circle or mark it with an 'X'.  If
              something that was supposed to be present is missing you can
              just circle the part of the question describing what was missed,
              rather than writing out a description.  If you need to write a
              description of an error just write a \textbf{few short} words.

        \item Mark negative deductions next to any mistakes, but write the
              total (positive) points for each question \textbf{next to its
              number} (\underline{next to where the question says ``[XX
              pts\.]}'').

              Also write the total score for that question in the space
              \textbf{\underline{on the front of the exam}} (so the total
              score for each question is written twice).

        \item For any problems with subparts where the subparts are worth
              different numbers of points, if the points for each subpart
              are not already marked on the exam then mark the points for each
              subpart as a fraction $\left(\frac{n}{m}\right)$ next to that
              subpart.

        \item Don't deduct fractional points; grade using whole number points
              only.

        \item Unless noted below, give partial credit according to the
              grading key if something is partially, but not completely,
              incorrect.

              Unless otherwise indicated, the points for tasks should be
              prorated if the task is partially but not completely right
              (i.e., partial credit should be given).

              In general try to avoid penalizing twice for the same problem,
              or don't penalize for a problem and then for each of its
              effects.

              % For example, suppose the grading key for a question says that
              % making a proper function call is \pts{3}-- you can deduct
              % (using uniform criteria) \pts{-1} if a call was given but has
              % some small mistakes, \pts{-2} if a call was given but has
              % larger mistakes, and \pts{-3} if the call is completely
              % missing or totally wrong.

        \item Anything correct gets full credit, even if it's not the same as
              the solution on the answer key (unless it contradicts what the
              question was asking for in some way, such as using some language
              feature that the problem said could not be used).

        \item Put your initials at the bottom of the page for each question you
              grade.

        \item Carefully add the point deductions for each problem to avoid
              mistakes.

        \item Write the numbers (the score for each question next to the
              question number, and on the front page)
              \textbf{\underline{\underline{neatly}}}.

        \item If you find common mistakes students made, or that several
              students have given the same incorrect answer, let us know.  It
              may be a common conceptual mistake that we didn't anticipate
              when writing the answer key.  In that case we may want to adjust
              the grading key, or make up a special deduction to handle that
              case.

        \item Write down all decisions about grading that are made on the
              grading key (anything that's not already on the grading key).
              Write your name on the pages of the key on the problems you
              graded.

        \item If you're grading a question together with anyone else the
              most important things are correctness of grading and
              \underline{consistency} of grading.  If you see any situations
              not addressed by the grading key, and we make any decisions
              about how to handle them, everyone grading that question must
              commnunicate that between yourselves, and you need to ask when
              you come across different situations to make certain you're
              deducting the same credit as everyone is for the same mistake.
              Anytime you see something you aren't sure about, check with the
              other graders grading that question to ensure any special
              situations are handled uniformly.

        \item If you have questions about anything while grading, be sure to
              ask.  We want to avoid having to go back and correct mistakes
              after things have been graded!

        \item After the exams are graded and returned, don't tell the students
              what the grading criteria were (number of points off for
              different mistakes).

      \end{enumerate}

      \vspace{-2.5mm}

      \pagebreak

    \end{info}

  }

  \begin{enumerate}

    \addtolength{\itemsep}{12mm}

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \item {[16 pts.]} The grammar in this problem has two aspects that
          didn't come up in the examples of left factoring shown in class.
          Firstly, the productions where left factoring must be performed
          are recursive.  However, The left factoring procedure that was
          shown works in this situation, but it's just a little different.
          Applying the procedure would result in this grammar (we added new
          nonterminals L and M):

          \hspace{.2in}%
          \begin{grammar}[1.35]

            \production{S}{\mathit{c}L \midspc \mathit{db}T \midspc
                           \mathit{bd}T \midspc T}
              \\

            \production{L}{\mathit{a}S \midspc \mathit{o}S}
              \\

            \production{T}{\mathit{a}M \midspc \mathit{b}}
              \\

            \production{M}{\mathit{a}T \midspc \mathit{b}T \midspc
                           \largeepsilon}
              \\

          \end{grammar}

          \smallskip

          The second aspect that comes up more indirectly here than in the
          examples from class is that the grammar above still doesn't have
          unique first sets for its productions.  \emph{b} is in first(T),
          as well as in first(\emph{bd}), so the S production has \emph{b}
          in the first of two of its right sides; consequently the procedure
          would have to be applied again.  Almost no one realized this, so
          we just gave full credit for applying the procedure once,
          resulting in the grammar above.  But a correct grammar produced by
          left factoring again would be (now adding the new nonterminal N):

          \hspace{.2in}%
          \begin{grammar}[1.35]

            \production{S}{\mathit{c}L \midspc \mathit{db}T \midspc
                           \mathit{b}N}
              \\

            \production{L}{\mathit{a}S \midspc \mathit{o}S}
              \\

            \production{T}{\mathit{a}M \midspc \mathit{b}}
              \\

            \production{M}{\mathit{a}T \midspc \mathit{b}T \midspc
                           \largeepsilon}
              \\

            \production{N}{\mathit{d}T \midspc \largeepsilon}
              \\

          \end{grammar}

          \smallskip

          Going back to the first grammar, note that just using the same
          nonterminal in the right sides of the new productions added,
          rather than the original nonterminal, would lead to productions
          that could never generate anything:

          \hspace{.2in}%
          \begin{grammar}[1.35]

            \production{S}{\mathit{c}L \midspc \mathit{db}T \midspc
                           \mathit{bd}T \midspc T}
              \\

            \production{L}{\mathit{a}L \midspc \mathit{o}L}
              \\

            \production{T}{\mathit{a}M \midspc \mathit{b}}
              \\

            \production{M}{\mathit{a}M \midspc \mathit{b}M \midspc
                           \largeepsilon}
              \\

          \end{grammar}

          \smallskip

          Any derivation that uses the nonterminal L will never terminate
          and derive a string.

          And note that just making the first added production recursive and
          adding an alternative for $\largeepsilon$, as in the grammar
          below, will allow generating invalid strings such as \emph{c},
          \emph{aaa}, \emph{aoa}, etc.

          \hspace{.2in}%
          \begin{grammar}[1.35]

            \production{S}{\mathit{c}L \midspc \mathit{db}T \midspc
                           \mathit{bd}T \midspc T}
              \\

            \production{L}{\mathit{a}L \midspc \mathit{o}L \midspc
                           \largeepsilon}
              \\

            \production{T}{\mathit{a}M \midspc \mathit{b}}
              \\

            \production{M}{\mathit{a}T \midspc \mathit{b}T \midspc
                           \largeepsilon}
              \\

          \end{grammar}

          \begin{info}{\textbf{\underline{Grading key:}}}

            \begin{itemize}

              \addtolength{\itemsep}{1mm}

              \item Deduct \pts{-2} if the answer just has one minor
                    mistake.

              \item Deduct \pts{-6} if the correct transformation was made
                    to one production, but not to the other.

              \item Also deduct \pts{-6} if the correct transformations were
                    done (mostly), but some unrelated and unnecessary
                    transformations were done (as long as the modified
                    grammar still generates the right language)

              \item Deduct \pts{-10} for making random incorrect
                    transformations that don't eliminate left recursion but
                    at least cause the resulting grammar to generate the
                    same language as the original grammar.

              \item Deduct \pts{-12} for making random incorrect
                    transformations that cause the grammar to not even
                    generate the right language any more.

            \end{itemize}

          \end{info}

          \vspace{-3mm}

          \enlargethispage{5mm}

          \begin{info}{\textbf{\underline{Grading notes:}}}

            \begin{itemize}

              \addtolength{\itemsep}{1mm}

              \item There is no penalty for omitting $\largeepsilon$ in the
                    last production and just using an empty alternative.

              \item Be sure to coordinate with anyone else also grading this
                    question for consistency of grading; ask me if you're
                    not sure how much credit to give.  \textbf{Write down on
                    this grading key} how many points you decide to give
                    for common situations not described here.

            \end{itemize}

          \end{info}

          \pagebreak

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \item {[20 pts.]}

          \vspace{-2.5mm}

          \begin{multicols}{2}

            \begin{enumerate}

              \addtolength{\itemsep}{0mm}

              \item This grammar can't generate some valid strings: those
                    without any \emph{b}s and \emph{c}s, such as \emph{d},
                    \emph{add}, etc., or any strings that have an unequal
                    number of \emph{b}s and \emph{c}s, such as \emph{abbbd}.

                    It's also ambiguous for any strings with more than one
                    \emph{b} and \emph{c}, such as \emph{bbccd},
                    \emph{bbbcccddd}, \emph{abbccdd}, etc.

                    \columnbreak

              \item This grammar generates invalid strings that have
                    \emph{d}s before \emph{b}s, such as \emph{adbbbd} and
                    \emph{aadbbbdd}. It also can't generate some valid
                    strings: those without any \emph{b}s and \emph{c}s,
                    such as \emph{d}, \emph{add}, etc.  Likewise
                    \emph{abcdd} and \emph{acccdd} can't be generated.

            \end{enumerate}

            \vspace{-2.5mm}

          \end{multicols}

          \medskip

          \begin{multicols}{2}

            \vspace{-2.5mm}

            \begin{enumerate}

              \addtolength{\itemsep}{0mm}

              \setcounter{enumii}{2}

              \item This grammar is ambigous for any strings other than
                    \emph{d}, \emph{bc}, \emph{bbcc}, and any strings that
                    have \emph{b}s but no \emph{c}s, or \emph{c}s but no
                    \emph{b}s (such as \emph{abbbdd}, \emph{aaccccccddd},
                    \emph{bbbd}, etc.).

                    \columnbreak

              \item Correct!

            \end{enumerate}

            \vspace{-2.5mm}

          \end{multicols}

          \begin{info}{\textbf{\underline{Grading key:}}}

            \begin{itemize}

              \addtolength{\itemsep}{2mm}

              \item Each part is \pts[circle]{5}  No justification is
                    necessary (like showing derivations for incorrect
                    strings that can be generated).

              \item No partial credit for part (d).

              \item For parts (a)--(c), if the identification of the problem
                    is right (for example saying the grammar is ambiguous in
                    part (c), or saying that it can't generate a valid
                    string in part (a)), but the example is wrong, deduct
                    \pts{-3} for that part.

              \item Be sure to coordinate with anyone else also grading this
                    question for consistency of grading; ask me if you're
                    not sure how much credit to give.  \textbf{Write down on
                    this grading key} how many points you decide to give
                    for common situations not described here.

            \end{itemize}

          \end{info}

          \pagebreak

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \item {[32 pts.]} Where the question talks about the grammar giving the
          interpretation that pipelines are performed or grouped in
          left--to--right order this means assocativity.  Writing a
          \textbf{left--recursive} production for generating pipelines will
          force the first pipeline in a sequence to be the lowest one in a
          parse tree, the next one to be applied to the result of the first
          one, etc.  (Note that nothing in the problem says that the grammar
          has to be suitable for parsing by a recursive descent parser,
          which would be the only case where a left recursive production
          would be a problem, and the requirement that pipelines be
          performed in left to right order necessitates a left--recursive
          production.)

          Where the question talks about input redirection having priority
          over pipelining, and pipelining having priority over output
          redirection, this means precedence, i.e., a hierarchy of
          productions must be introduced.

          \renewcommand{\midspc}{\mbox{\huge \ensuremath{\ \mid \ }}}

          We use nonterminals F for filenames and C for commands, and we
          made the vertical bar separating right--hand sides of productions
          {\Large really big} so as to differentiate it from the pipeline
          terminal symbol.

          \hspace{.2in}
          \begin{minipage}[t]{6in}

            \begin{grammar}[2]

              \production{S}{T \midspc T \ \: \texttt{>} \ \: F}
              \\

              \production{T}{T \ \: \texttt{|\&} \ \: C \midspc U}
              \\

              \production{U}{C \ \: \texttt{<} \ \: F \midspc C}
              \\

              \production{F}{\texttt{f} \midspc \texttt{g} \midspc \texttt{h}}
              \\

              \production{C}{\texttt{a} \midspc \texttt{b} \midspc \texttt{c}}
              \\

            \end{grammar}

          \end{minipage}

          \medskip

          \addtolength{\columnsep}{2mm}

          \begin{multicols}{2}

            Note this version of the grammar (which differs only in the
            first alternative for T) is close to being correct, but it would
            allow generating invalid commands in which programs in the
            middle of a pipeline can have input or output redirection, such
            as the example \texttt{a |\& b < f |\& c}.

            \smallskip

            \hspace{.2in}
            \begin{minipage}[t]{2.9in}

              \begin{grammar}[2]

                \production{S}{T \midspc T \ \: \texttt{>} \ \: F}
                \\

                \production{T}{T \ \: \texttt{|\&} \ \: U \midspc U}
                \\

                \production{U}{C \ \: \texttt{<} \ \: F \midspc C}
                \\

                \production{F}
                           {\texttt{f} \midspc \texttt{g} \midspc \texttt{h}}
                \\

                \production{C}
                           {\texttt{a} \midspc \texttt{b} \midspc \texttt{c}}
                \\

              \end{grammar}

            \end{minipage}

            \columnbreak

            Also note that using recursion for the productions generating
            input or output redirection, as in the productions for S and U
            in the grammar below, would allow generating invalid commands in
            which a program has redirection from multiple input or output
            files, such as \texttt{a < f < g}.

            \smallskip

            \hspace{.2in}
            \begin{minipage}[t]{2.9in}

              \begin{grammar}[2]

                \production{S}{T \midspc S \ \: \texttt{>} \ \: F}
                \\

                \production{T}{T \ \: \texttt{|\&} \ \: C \midspc U}
                \\

                \production{U}{U \ \: \texttt{<} \ \: F \midspc C}
                \\

                \production{F}
                           {\texttt{f} \midspc \texttt{g} \midspc \texttt{h}}
                \\

                \production{C}
                           {\texttt{a} \midspc \texttt{b} \midspc \texttt{c}}
                \\

              \end{grammar}

            \end{minipage}

          \end{multicols}

          \vspace{-5mm}

          \enlargethispage{5mm}

          \begin{info}{\textbf{\underline{Grading key:}}}

            \begin{itemize}

              \addtolength{\itemsep}{1.5mm}

              \item Any answer should have the following five properties:

                    \vspace{.5mm}

                    \begin{description}

                      \item[correctness:] The grammar generates only valid
                            commands (and does not generate any invalid
                            commands).

                      \item[completeness:] The grammar generates every valid
                            command.

                      \item[precedence:] The grammar enforces the precedence
                            or priority given for the three command operators
                            or symbols.

                      \item[associativity:] The grammar enforces
                            left--to--right grouping (or associativity) of
                            the pipeline operator or symbol.

                      \item[unambiguousness:] The grammar is unambiguous.

                    \end{description}

                    \vspace{-0mm}

              \item Correctness and completeness are \pts[circle]{7} each; the
                    other properties are \pts[circle]{6} each; deduct as
                    follows:

                    \vspace{-0mm}

                    \begin{description}

                      \addtolength{\itemsep}{0mm}

                      \item[for problems with correctness:] Deduct \pts{-3} if
                            there is one problem with correctness (one source
                            in the grammar of incorrect strings being
                            generated), or no credit for correctness
                            (\pts{-7}) if there is more than one.

                      \item[for problems with completeness:] Deduct \pts{-3}
                            if there is one problem with completeness (one
                            source in the grammar that prevents some correct
                            strings from being generated), or no credit for
                            completeness (\pts{-7}) if there is more than one.

                      \item[for problems with precedence:] Deduct \pts{-3} if
                            there was at least an attempt to ensure precedence
                            (there was some hierarchy to the productions),
                            while if all operators are at the same level
                            deduct \pts{-6}

                      \item[for problems with associativity:] Deduct \pts{-3}
                            if the pipeline operator was performed in
                            right--to--left order, and \pts{-6} if the
                            evaluation order was totally unenforced (for
                            example, a production like
                            \production{T}{T \ \: \texttt{|\&} \ \: T \midspc
                            U}).

                      \item[for problems with ambiguity:] Deduct \pts{-3} if
                            there is one problem with ambiguity (one source of
                            ambiguity in the grammar), or no credit for
                            ambiguity (\pts{-6}) if there is more than one.

                    \end{description}

                    \vspace{-0mm}

              \item Deduct \pts{-1} or \pts{-2} (depending upon how pervasive
                    the problem is) for small mistakes such as using angle
                    braces or quotation marks around terminal symbols (for
                    example, \texttt{<a>}, \texttt{<b>},
                    \texttt{<}\verb@|&@\texttt{>}.

              \item Be sure to coordinate with anyone else also grading this
                    question for consistency of grading; ask me if you're
                    not sure how much credit to give.  \textbf{Write down on
                    this grading key} how many points you decide to give
                    for common situations not described here.

            \end{itemize}

            \vspace{-2.5mm}

          \end{info}

          \begin{info}{\textbf{\underline{Grading notes:}}}

            \begin{itemize}

              \addtolength{\itemsep}{2mm}

              \item For ambiguity, look for whether the answer
                    incorrectly contains productions which just go to
                    nonterminals of earlier productions in the hierarchy as a
                    right--side alternative, for example, if the answer had a
                    production such as \hspace{2mm}
                    \production{T}
                               {T \ \: \texttt{|\&} \ \: C \midspc U \midspc S}

              \item The grammar could be ambiguous even if all productions
                    have only nonterminals lower in the hierarchy of
                    productions, if several productions have producions
                    containing the same single nonterminal.  For example:

                    \vspace{-1mm}

                    \hspace{.25in}
                    \begin{grammar}

                      \production{S}
                                 {T \midspc T \ \: \texttt{>} \ \: F \midspc U}
                      \\

                      \production{T}{T \ \: \texttt{|\&} \ \: C \midspc U}
                      \\

                      \textrm{etc.}

                    \end{grammar}

              \item The grammar should enforce left--associativity or
                    left--to--right execution of commands in a pipeline with
                    left--recursive productions.

                    Look for incorrect productions like
                    \(
                      \mathrm{
                      \production{T}{T \ \: \texttt{|\&} \ \: T \midspc U}
                      }
                    \), where the second T on the right--side should be a C.

              \item The grammar should enforce the precedence of the command
                    operators by arranging productions in a strict hierarchy
                    by the operators' precedence (in inverse order of
                    precedence or priority).

                    \enlargethispage{5mm}

              \item Be sure the answer \textbf{can} generate special cases
                    such as:

                    \vspace{-3mm}

                    \begin{multicols}{4}

                      \centering

                      \verb@a < f > g@

                      \columnbreak

                      \verb@a > f@

                      \columnbreak

                      \verb@a@

                    \end{multicols}

                    \vspace{-3mm}

              \item Also be sure the answer isn't ambiguous for generating
                    special cases, such as single commands with no redirection
                    (for example \verb@a@).

              \item Be sure the answer \textbf{cannot} generate special cases
                    such as:

                    \vspace{-3mm}

                    \begin{multicols}{4}

                      \centering

                      \verb@a < > g@

                      \verb@a <@

                      \columnbreak

                      \verb@a < |& > f@

                      \columnbreak

                      \verb@a |&@

                    \end{multicols}

                    \vspace{-3mm}

              \item There's no penalty for extra productions.  In other words,
                    the grammar need not be minimal, so do not deduct for
                    having useless nonterminals, etc.  For example, a grammar
                    with productions like the following is fine:
                    \begin{grammar}
                      \production{U}{C \ \: op \ \: F \midspc C}
                      \\
                      \production{op}{\texttt{<}}
                    \end{grammar}

              \item If a grammar is given that omits input redirection
                    entirely (the suggestion in the last sentence of the
                    problem description), the answer should lose \pts{-3}
                    for precedence and \pts{-3} for completeness, plus any
                    other deductions for other mistakes in the grammar.

            \end{itemize}

            \vspace{-2.5mm}

          \end{info}

          \pagebreak

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \item {[32 pts.]} Perhaps the most elegant way to solve this problem is
          using a higher--order functional programming paradigm not
          discussed in class yet this semester, so you would probably not
          know about it, but we explain it here.  It is a higher--order
          function named filter, which takes a predicate (a boolean--valued
          function) and a list, and applies the function to every element of
          the list, returning a list with only the elements of its parameter
          list for which the predicate was true.  We can create one function
          that will return true for elements of quicksort's list argument
          that are less than the pivot, and one that will return true for
          the elements of its argument list that are greater than or equal
          to the pivot, and apply them both to the list to partition the
          list.

          In order to do this we use the fact that OCaml's built--in
          operators can be passed as arguments to functions by surrounding
          them in parentheses.  Or we could pass anonymous functions like
          \texttt{(fun x y -> x >= y)} and \texttt{(fun x y -> x < y)}
          instead.

          Here is what this solution would look like:

          \vspace{-2.5mm}

          \begin{center}

            \begin{Verbatim}[gobble=0]
let rec filter predicate = function
    [] -> []
  | h::t -> let rest = filter predicate t in
              if predicate h
                then h::rest
                else rest;;

let rec quicksort = function
    [] -> []
  | pivot::t ->
      let lessthan_pivot = ((>=) pivot) in
        let greaterthanorequal_pivot = ((<) pivot) in
          let firstpart = quicksort (filter lessthan_pivot t) in
            let secondpart = quicksort (filter greaterthanorequal_pivot t) in
              firstpart @ [pivot] @ secondpart;;
            \end{Verbatim}

          \end{center}

          \vspace{-1mm}

          Notice that the \texttt{filter} function's first argument is a
          predicate that is applied to one argument-- each element of the
          list-- while the \texttt{<} and \texttt{>=} operators in OCaml are
          applied to two arguments.  What we need is to create two functions
          that will each take one argument and compare it (using \texttt{<}
          or \texttt{>=}) to a single element.  This is easy with currying--
          we create two functions (called \texttt{lessthan\_pivot} and
          \texttt{greaterthanorequal\_pivot}) that are each closures
          consisting of one of the operators \texttt{<} or \texttt{>=} plus
          they capture the pivot in their environment.  They only need one
          additional argument to be supplied, which will be compared to the
          pivot.  Lastly, note that since \texttt{<} and \texttt{>=} both
          compare their two arguments, returning true if the relationship is
          true between them, to create a function that returns true if its
          argument is less than the pivot what we really need is
          \texttt{((>=) pivot}, and to create a function that returns true
          if its argument is greater than or equal to the pivot what we
          really need is \texttt{((<) pivot}.

          \bigskip

          Here is a version that does not use the filter function paradigm
          or higher--order functions:

          \vspace{-2.5mm}

          \begin{center}

            \begin{Verbatim}
        let rec all_lessthan element list =
          match list with
             [] -> []
           | h::t -> if (h < element)
                       then h::(all_lessthan element t)
                     else (all_lessthan element t);;

        let rec all_greaterthanorequal element list =
          match list with
             [] -> []
           | h::t -> if (h >= element)
                       then h::(all_greaterthanorequal element t)
                     else (all_greaterthanorequal element t);;

        let rec quicksort list =
          match list with
            [] -> []
          | pivot::t -> (quicksort (all_lessthan pivot t)) @ [pivot] @
                        (quicksort (all_greaterthanorequal pivot t));;
            \end{Verbatim}

          \end{center}

          \bigskip

          This solution does not use filter or higher--order functions yet
          only has one helper function, but one that returns a tuple:

          \vspace{-2.5mm}

          \begin{center}

            \begin{Verbatim}
        let rec split pivot = function
            [] -> ([], [])
          | h::t ->
              let (lt, gt) = split pivot t in
                if h < pivot
                  then (h::lt, gt)
                  else (lt, h::gt);;

        let rec quicksort = function
            [] -> []
          | pivot::t -> let (lt, gt) = split pivot t in
              (quicksort lt) @ [pivot] @ (quicksort gt);;
            \end{Verbatim}

          \end{center}

          \medskip

          \pagebreak

          \begin{info}{\textbf{\underline{Grading key:}}}

            \begin{itemize}

              \addtolength{\itemsep}{2mm}

              \item A correct solution should perform the following
                    conceptual tasks, which are listed with their point
                    values:

                    \smallskip

                    \begin{enumerate}

                      \addtolength{\itemsep}{0mm}

                      \renewcommand{\labelitemii}{$\ast$}

                      \item Handling the empty list case (\pts[circle]{2})

                      \item Isolating the pivot (e.g., something like
                            \texttt{pivot::t}) (\pts[circle]{2})

                      \item Calling something that partitions the list twice
                            on the pivot and everything other than the
                            pivot, to get the elements less than the pivot
                            and those greater than or equal to it
                            (\pts[circle]{6})

                      \item Recursively sorting both (partitioned) parts
                            (\pts[circle]{6})

                      \item Combining (appending) both sorted parts, with
                            the pivot between them, with the pivot included
                            exactly once (not more than once, and not
                            omitted) (\pts[circle]{6})

                      \item In some type of helper function or helper
                            functions, handling the empty list case
                            (\pts[circle]{2})

                      \item In some type of helper function or helper
                            functions, isolating the first element of its
                            list parameter (e.g., something like
                            \texttt{h::t}) (\pts[circle]{2})

                      \item In some type of helper function or helper
                            functions, comparing the pivot to the first
                            element of the list parameter (\pts[circle]{2})

                      \item In some type of helper function or helper
                            functions, including the head element in the
                            result only if it has the proper relationship to
                            the pivot (\pts[circle]{2})

                      \item In some type of helper function or helper
                            functions, making a correct recursive call on
                            the pivot and the rest of the list parameter
                            (\pts[circle]{2})

                    \end{enumerate}

                    \medskip

                    Note that the helper function is \pts{10} total, and the
                    main function is \pts{22}

                    \medskip

                    Partial credit should be given for tasks that are
                    attempted and partly right, but that have some
                    mistakes, using consistent and uniform criteria.

                    \smallskip

              \item Ignore minor mistakes in syntax if the intention is
                    clear.  Deduct \pts{-1} for each more significant minor
                    error.

              \item Be sure to coordinate with anyone else also grading this
                    question for consistency of grading; ask me if you're
                    not sure how much credit to give.  \textbf{Write down on
                    this grading key} how many points you decide to give
                    for common situations not described here.

            \end{itemize}

            \vspace{-2.5mm}

          \end{info}

          \begin{info}{\textbf{\underline{Grading notes:}}}

            \begin{itemize}

              \addtolength{\itemsep}{2mm}

              \item Don't penalize for inefficiency (for example, maybe the
                    student's partition function is correct but is
                    $\mathcal{O}(n^2)$), as long as the quicksort algorithm
                    is being performed.

              \item It's not a problem if the list elements are partitioned
                    into those less than or equal to the pivot, and those
                    greater than (the question just described it the other
                    way, but both are correct).

              \item Talk to me about how many points to deduct if any
                    answers don't really partition or sort the list (they
                    just rearrange some elements).

            \end{itemize}

            \vspace{-2.5mm}

          \end{info}

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \end{enumerate}

\end{document}
