\documentclass[12pt]{article}

  \usepackage{330-f12}

  \pagestyle{empty}

\begin{document}

  \header{\course}{Discussion section topics -- Week \#11}{\Term}

  \section{Discussion \#10, Friday, November 9}

    \subsection{Parsing}

      There are two recursive descent parsing examples in my directory, the
    second one being an extension of the first one.  Show and explain these
    so students understand.  You could first show them the grammar, and ask
    them how the parser would be written.  Here are some issues and points
    to make:
    
      \vspace{-1.5mm}

      \begin{itemize}

        \addtolength{\itemsep}{0mm}

        \item Both programs parse arithmetic expressions, using the
              operators and operands in the grammar at the top.  To make
              things easy, the grammar is written to be
              \textbf{right--recursive}, so it's not necessary to modify it
              to eliminate left recursion.  This means that the operators
              will have the interpretation that they are
              \textbf{right--associative} in this grammar and program, not
              left--associative.

        \item The first version of the program just parses an arithmetic
              expression.  The program does not use an explicit (separate)
              variable for the lookahead; the lookahead is just the first
              element of the list \texttt{lr} (an expression is entered as a
              string, such as \texttt{parse\_expr "2 + 3 * 4";;}, and
              converted to a list of characters).  If the parser gets to the
              end of the expression (the whole expression is consumed during
              the parse) then it must be syntactically valid.  Otherwise it
              must have an error.  Different types of errors are manifested
              in different ways (by different conditions in the parsing
              process).  Explain and run the program as necessary.

              Note that although the lecture slides about recursive descent
              parsing imply an explicit variable is used for the
              lookahead, the lookahead is implicit here.  The input
              expression, in the form of a string, is converted to a list of
              characters, and the lookahead is always just the first element
              in the list.  The lookahead is consumed or skipped by just
              removing the first element of the list.

        \item As motivation for the second version of the program, we notice
              that while the parser is parsing expressions, it can also
              build and return an AST (abstract syntax tree) of the
              expression in the process.  First show the type definition of
              \texttt{arith} that represents ASTs in the second program, or
              try to ask students what it could look like.  Then show or ask
              them how the parsing functions could be modified to create and
              return components of the AST.

        \item Then explain, or ask the students how we would write, a simple
              interpreter for these arithmetic expressions, which would look
              at an AST created by \texttt{parse\_expr} and evaluate it.
              Show, run, and explain the function eval, which would be
              called as \texttt{eval (parse\_expr "2 + 3 * 4");;}.  (Note
              again that the operators are \textbf{right--associative} in
              this grammar, just to make the example simpler.)

        \item Lastly (hopefully there will be time), relate this to Project
              \#4, in which students will also have to write a recursive
              descent parser and an interpreter.  The main difference is
              that in the mini--interpreter in this example (\texttt{eval}),
              the only possible type of values that expressions can produce
              are integers, while in the project, expressions can result in
              an integer, an identifier, a boolean value, a string, a list,
              and other types.  So unlike the simple \texttt{eval} function
              here, the students' interpreter for Project \#4 is going to
              have to define an OCaml type to represent the return value of
              expressions.  The type will have to be able to represent the
              different possible types that expressions can result in
              (integers, identifiers, etc.), and the \texttt{eval} function
              will have to return something of that type.  \texttt{eval} in
              the project will have to look at each component of an
              expression to be evaluated and return one of the options of
              the type representing values.

      \end{itemize}

      \vspace{-2.5mm}

    \subsection{If you have extra time}

      If you have any extra time, instead of letting the students go early,
    see if they have any questions and try to answer them if so.  There may
    be questions about the material that the exam will cover.

    \subsection{Quiz \#4}

      Please review the quiz information from the earlier discussion topics
    so everything is clear.

      Stop the above so the students have 15 minutes at the end of the section
    to do the quiz (or earlier or later if we decide that any particular
    quiz should have more time).

      When handing out the quiz, emphasize that students \textbf{must} put
    their complete identifying information on the front (name, University ID
    number, TA's name, and discussion section time).

      Give the quiz at the end of the discussion.  Count the number of
    students taking the quiz during each section, and write it down and save
    it.  Count the number of quizzes turned in and make sure it agrees.

\end{document}
