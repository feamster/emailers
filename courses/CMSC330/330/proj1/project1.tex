\documentclass[11pt]{article}

  %
  % Test an empty input file with no lines?
  %

  %
  % Next time mention diff's unified output format, with -u, as it may be
  % easier to read.
  %

  %
  % Should not have used "interface" in the first public test, since that
  % tested the longest match criteria....
  %

  %
  % In the past, on similar projects, students asked a lot of questions (in
  % the forum or newsgroup or Piazza) like "is W a valid X token?" or "is Y
  % a valid Z token?".  Rather than having the TAs act as a grading oracle,
  % telling the students what's valid and invalid, if students ask a lot of
  % these types of questions this semester tell the TAs to instead ask them
  % something like "please state the project says about X or Z tokens, and
  % whether based on that you believe that W or Y is valid or not, giving
  % your reasoning, and then we can either confirm or correct your
  % reasoning".  Otherwise, we could have students being lazy and just
  % asking us for dozens of possible cases what the result should be,
  % without trying to figure it out themselves.
  %

  %
  % Next time prevent copy/paste of project PDFs....
  %

  \usepackage[none,light,outline,timestamp]{draftcopy}

  \usepackage{330-f12}

  % so the wide example won't be wider than the page width
  \addtolength{\oddsidemargin}{-.125in}
  \addtolength{\evensidemargin}{-.125in}
  \addtolength{\textwidth}{.25in}
  \setlength{\columnsep}{7.75mm}  % overrule what's in the style file

  %
  % Print something in typewriter font with real upright quotes.
  %
  \usepackage{textcomp}  % to get upright single quote
  \newcommand{\squoted}[1]{\texttt{\textquotesingle#1\textquotesingle}}

\begin{document}

  \header{\course}{Project \#1}{\Term}

  \vspace{-2mm}

  \begin{centering}

    Date due: Wednesday, October 3, 10:00:00 p.m.

  \end{centering}

  \vspace{-3.5mm}

  % \addtolength{\baselineskip}{2.75mm}

  \section{Introduction}

    In this project you are to write a Ruby program that will read Java tokens
  as input, and perform simple syntax highlighting.  Tokens are the
  fundamental syntactic entities of a programming language, and the first
  phase of compilation or interpretation, which is scanning or lexical
  analysis, involves reading the program to be compiled or interpreted and
  breaking it up into its constituent tokens.  Each language has its own
  specific definition of tokens, but typical tokens include operators,
  identifiers, character strings, integers, floats, etc.  Compilers,
  interpreters, debuggers, and other programs that have to read and
  understand programs or fragments of program text typically use regular
  expressions to describe tokens.

    Syntax highlighting refers to the ability of some text editors, such as
  Emacs or the Eclipse text editor for example, to display information using
  different fonts and colors, depending upon the types of items that appear.
  For example, syntax highlighting of a file in a programming language might
  display reserved words in one color or font, comments in a different color
  or font, character string literals in another color or font, etc.  In this
  program you won't be implementing a text editor, but rather your program
  will read input representing Java tokens and output HTML code which, if
  viewed in a web browser, would display the Java tokens in different colors
  and fonts.  You will have to write various Ruby regular expressions to
  recognize the different types of Java tokens that may appear in the input.

    In grading we will check your program's output to see whether it is
  correct, but we won't be displaying it in a web browser.  However, you can
  view its output in a browser, which may be a way to easily see whether
  your program is working to at least a certain extent or not.

    It's important to point out that if this was a real program it would
  probably not be written in the way you will have to write it.  Recognizing
  the validity of complex input such as Java source code would be done in
  practice using parsing techniques and tools, but the project is just an
  exercise in learning and using regular expressions, and also of course
  getting experience coding in Ruby.

    A separate handout has been placed on the class webpage (under
  ``Administrative and information'') that details the course project
  grading and submission policies, and also describe how to set up your
  account on the Grace machines.  Once you have set up your account (you
  must have done so first), to start working on the project just log into
  the Grace machines and use the commands:

    \medskip

    \begin{centering}

      \begin{BVerbatim}[gobble=6]
      cp -r ~/330public/proj1 ~/330
      cd ~/330/proj1
      \end{BVerbatim}

    \end{centering}

    \medskip

    The directory \texttt{proj1} that you will be copying contains the public
  test inputs and outputs, two other project files mentioned below, and a
  (hidden) file \texttt{.submit} that will allow the project submission
  program to submit your code.  As above, cd to the directory \texttt{proj1}
  created in your extra course disk space, and do your programming there, as
  your project will need to be in that directory when you submit.

    Note that as of the time this project assignment is being posted the
  project hasn't been set up on the submit server yet, but that will be done
  in a few days.  However, the \texttt{proj1} directory created above
  contains the public test inputs, and their corresponding outputs, so you
  can determine yourself exactly whether your program works for those inputs
  or not.

  \section{Program input, output, and identification of tokens}

    \subsection{Input}

      Your program is to be able to recognize ten different types of tokens in
    its input, as described below.  In the discussion below ``whitespace
    character'' refers to a blank space, tab, newline, or carriage return
    character, and ``whitespace'' refers to a sequence of one or more
    consecutive whitespace characters.

      Your program must read from its standard input a sequence of zero or
    more lines, each of which will end with a newline, and each of which can
    contain zero or more characters before the terminating newline.

      \subsubsection{Java tokens}

        The following are the types of tokens that your program must be able
      to identify, and their descriptions.  Note that the token type names
      will be included in your program's output.

        \begin{description}

          \addtolength{\itemsep}{.75mm}

          \item[ID:] ID refers to a Java identifier, which begins with a
                Java letter; the Java letter is followed by any sequence of
                zero or more Java letters or digit characters (or both).
                Java letters are considered to be the uppercase and
                lowercase English alphabet characters, as well as the
                underscore (\texttt{\_}) and dollar sign (\texttt{\$})
                characters.  The digit characters are just \texttt{0}
                through \texttt{9}.

          \item[KEY:] KEY refers to a Java keyword, of which, for purposes
                of this project, the following 50 exist:

                \vspace{-2.5mm}

                \begin{multicols}{5}

                  \addtolength{\baselineskip}{-.75mm}

                  \texttt{abstract}

                  \texttt{assert}

                  \texttt{boolean}

                  \texttt{break}

                  \texttt{byte}

                  \texttt{case}

                  \texttt{catch}

                  \texttt{char}

                  \texttt{class}

                  \texttt{const}

                  \texttt{continue}

                  \texttt{default}

                  \texttt{do}

                  \texttt{double}

                  \texttt{else}

                  \texttt{enum}

                  \texttt{extends}

                  \texttt{final}

                  \texttt{finally}

                  \texttt{float}

                  \texttt{for}

                  \texttt{goto}

                  \texttt{if}

                  \texttt{implements}

                  \texttt{import}

                  \texttt{instanceof}

                  \texttt{int}

                  \texttt{interface}

                  \texttt{long}

                  \texttt{native}

                  \texttt{new}

                  \texttt{package}

                  \texttt{private}

                  \texttt{protected}

                  \texttt{public}

                  \texttt{return}

                  \texttt{short}

                  \texttt{static}

                  \texttt{strictfp}

                  \texttt{super}

                  \texttt{switch}

                  \texttt{synchronized}

                  \texttt{this}

                  \texttt{throw}

                  \texttt{throws}

                  \texttt{transient}

                  \texttt{try}

                  \texttt{void}

                  \texttt{volatile}

                  \texttt{while}

                \end{multicols}

                \vspace{-2.5mm}

                The keywords are all case--sensitive and must be spelled
                exactly as above.  Note that although the keywords also
                satisfy the description of Java identifiers ID above, these
                50 words must be categorized as keywords.

          \item[BOOL:] BOOL refers to a Java boolean literal, of which there
                are two: \texttt{true} and \texttt{false}.  Boolean literals
                are also case--sensitive, and must also be spelled exactly
                as shown.  The boolean literals would also satisfy the
                description of Java identifiers ID above, but must be
                categorized instead as BOOL.

          \item[INT:] INT refers to Java literal integers, which are
                nonempty sequences of octal, decimal, or hexadecimal digits
                that follow the restrictions below.  The octal digits are
                \texttt{0} through \texttt{7}, while the decimal digits are
                \texttt{0} through \texttt{9}, and the hexadecimal digits
                are \texttt{0} through \texttt{9} and also the lowercase
                letters \texttt{a} through \texttt{f} and the uppercase
                letters \texttt{A} through \texttt{F}.

                The base of the number is determined by the beginning of the
                literal:

                \vspace{-2.5mm}

                \begin{itemize}

                  \item Octal numbers begin with a leading \texttt{0}, which
                        is followed by one or more octal digits.  For
                        example, \texttt{0237} is a valid integer literal,
                        but \texttt{058} is not, since \texttt{8} is not an
                        octal digit.

                  \item Hexadecimal numbers begin with either the character
                        sequence \texttt{0x} or the sequence \texttt{0X},
                        which is followed by one or more hexadecimal digits.
                        For example, \texttt{0x4a8} and \texttt{0xACED} are
                        valid integer literals.

                  \item Any other consecutive sequence of one or more digits
                        is a decimal integer literal.  For example,
                        \texttt{330} is a valid integer literal, but
                        \texttt{33a} is not.

                \end{itemize}

                \vspace{-2.5mm}

                Note that \texttt{0} is also a valid integer literal whose
                base is immaterial.  Also note that by the above definition,
                signed integer literals are not possible in this project.

                Any integer constant, of any base, including \texttt{0}, may
                optionally be followed by a long type modifier, which is
                either an uppercase \texttt{L} or a lowercase \texttt{l}.
                For example, \texttt{0x1aL} and \texttt{330l} are both valid
                integer constants.

          \item[FLOAT:] FLOAT refers to Java real literals, which are
                sequences of one or more decimal digits with an optional
                decimal point, optionally followed by an exponent part.  At
                least one digit must appear before the exponent if it is
                present.  Either the decimal point or the exponent may be
                omitted, but not both.  An exponent consists of an exponent
                marker (either \texttt{e} or \texttt{E}), optionally
                followed by a sign (\texttt{+} or \texttt{-}), followed by
                one or more decimal digits.  The entire literal (including
                the exponent if present) can optionally end with one of the
                letters \texttt{f}, \texttt{F}, \texttt{d} or \texttt{D} to
                denote a single or double precision constant.  Note also
                that signed float literals are also not possible.

          \item[CHAR:] CHAR represents a Java character literal, which is
                either a single character enclosed in single quote marks
                (\textquotesingle\textquotesingle), or is an escape sequence
                enclosed in single quote marks.  Any character other than a
                newline or a single quote may appear as a single character
                in a character literal.  Escape sequences begin with a
                backslash (\verb@\@), which is followed by any
                character other than a newline.  All of the following are
                examples of valid character literals: \squoted{a},
                \squoted{\string\a}, \squoted{\string\n},
                \squoted{\string\\}, and
                \texttt{\textquotesingle}\verb@\@\texttt{\textquotesingle}%
                \texttt{\textquotesingle}, while \squoted{\textquotesingle}
                is not.

          \item[STR:] STR represents Java character strings.  A Java string
                is a sequence of zero or more characters enclosed by
                double--quote marks (\texttt{"}).  Any Java character
                literal (defined under CHAR above, without surrounding
                single--quote marks) may appear between the double quotes of
                a Java string, other than a double quote mark itself.  A
                double quote mark \textbf{may} be included in a Java string
                by using the escape sequence \texttt{\string\"}.  Such an
                escape sequence cannot be the double quote mark that
                terminates the Java string.

          \item[OPER:] OPER represents Java operators, of which the following
                37 exist:

                \vspace{-2mm}

                \begin{multicols}{10}

                  \addtolength{\baselineskip}{-.75mm}

                  \centering

                  \verb@!@

                  \verb@!=@

                  \verb@%@

                  \verb@%=@

                  \verb@&@

                  \verb@&&@

                  \verb@&=@

                  \verb@*@

                  \verb@*=@

                  \verb@+@

                  \verb@++@

                  \verb@+=@

                  \verb@-@

                  \verb@--@

                  \verb@-=@

                  \verb@/@

                  \verb@/=@

                  \verb@:@

                  \verb@<@

                  \verb@<<@

                  \verb@<<=@

                  \verb@<=@

                  \verb@=@

                  \verb@==@

                  \verb@>@

                  \verb@>=@

                  \verb@>>@

                  \verb@>>=@

                  \verb@>>>@

                  \verb@>>>=@

                  \verb@?@

                  \verb@^@

                  \verb@^=@

                  \verb@|@

                  \verb@|=@

                  \verb@||@

                  \verb@~@

                \end{multicols}

                \vspace{-3.5mm}

          \item[COMM:] COMM represents Java comments, which can just be
                considered to be long tokens.  Only one type of comment is
                possible in this project, which is a single--line comment
                that begins with \texttt{//} and consists of all of the
                characters following that, until the newline marking the end
                of the input line.  Consequently a newline cannot be present
                in a comment of this type.

          \item[OTHER:] OTHER represents any sequence of characters that
                doesn't match any of the token types listed above.

        \end{description}

        \vspace{-.5mm}

        The input to your program will be very similar to a sequence of tokens
      in real Java, but there are some differences in tokens as described
      here compared to tokens in real Java.  Your program should recognize
      tokens as described above, \textbf{rather than} what would be the case
      for real Java, in all cases where these would differ, so if you have
      any questions about how tokens should be classified you should refer
      to the descriptions above rather than to a Java reference (and rather
      than checking what a Java compiler would accept).

    \subsection{Output}

      Your program must write all of its results to its standard output.
    For every token type \textbf{other than} OTHER, your program must print an
    HTML \texttt{span} element, which is just a string of the form:

      \medskip

      \begin{centering}

      \begin{BVerbatim}[gobble=6,commandchars=\\\{\}]
      <span class="\emph{\textrm{type}}">\emph{\textrm{output-token}}</span>
      \end{BVerbatim}

      \end{centering}

      \medskip

    \noindent
    where \emph{type} represents the type name of the Java token (one of the
    words ID, KEY, BOOL, INT, etc.), and \emph{output--token} represents a
    slightly--modified version of the token itself, produced from the token
    that was read by performing any of the following four replacements, if
    applicable:

      \medskip

      \begin{centering}

        \begin{tabular}[t]{|c|c|}

          \multicolumn{1}{c}{character}
            & \multicolumn{1}{c}{replacement text}
            \\ \hline

          \verb@&@
            & \verb@&amp;@
            \\ \hline

          \verb@<@
            & \verb@&lt;@
            \\ \hline

          \verb@>@
            & \verb@&gt;@
            \\ \hline

          \verb@"@
            & \verb@&quot;@
            \\ \hline

        \end{tabular}

      \end{centering}

      \bigskip\medskip

      For example, if the input contains the INT token \texttt{330}, the
    output that must be produced for this part of the input should be:

      \begin{centering}

        \verb@<span class="INT">330</span>@.

      \end{centering}

      \medskip\smallskip

      If the input contains the STR token \texttt{"Ruby"}, the output produced
    for it should be

      \medskip

      \begin{centering}

        \verb@<span class="STR">&quot;Ruby&quot;</span>@

      \end{centering}

      \medskip\smallskip

      Tokens of type OTHER should be printed (almost) exactly as they appear
    in the input, meaning \textbf{without} a span element, but \textbf{with}
    the four replacements mentioned above performed, if applicable.  Note
    that since whitespace matches the OTHER token, and tokens of type OTHER
    should be printed exactly to the output exactly as they appeared in the
    input (other than the four replacements, which obviously would not apply
    to whitespace), all whitespace in the input will be preserved exactly in
    the output.

    \subsection{Command--line argument}

      In order that the output of your program will be valid HTML that can be
    read by a web browser, it must be preceded by a prologue and followed by
    an epilogue.  If the single argument \texttt{-n} appears on the
    command line then the printing of the prologue and epilogue
    must be suppressed, otherwise they must both be printed.  Additional or
    invalid command--line arguments (anything other than \texttt{-n}) should
    simply be ignored.

      The prologue that should be printed consists of the following exact text
    (which will be placed on the Grace machines, where you can copy it
    without needing to type it manually, which could lead to errors).  Unless
    the option \texttt{-n} appears, the prologue must be the very first
    output that is printed.

      \vspace{-1.5mm}

      \begin{quote}

        \VerbatimInput[gobble=0]{prologue}

      \end{quote}

      \vspace{-1.5mm}

      Note that the output produced by your program must begin
    \textbf{immediately} after the opening \texttt{<tt>} tag, meaning
    following it on the same line, as the example below illustrates.

      The epilogue that should be printed as your program's very last output
    (unless the option \texttt{-n} is given) is the exact following lines
    (this will also be placed on the Grace machines):

      \vspace{-2mm}

      \begin{quote}

        \VerbatimInput[gobble=0]{epilogue}

      \end{quote}

      \vspace{-3mm}

    \subsection{Identification of tokens}

      In many programming languages there is no specific separator between
    tokens.  Tokens may be separated by whitespace, and in many languages
    many types of tokens may simply be adjacent.  In this project whitespace
    is matched by OTHER, therefore tokens are always considered to be
    adjacent.  The first token always starts at the \textbf{beginning} of an
    input line.  The second token starts with the very first character that
    does not belong to the first token, and so on.  Therefore determining
    where a token starts just depends upon where the previous token ended.
    Note that there are no multiline tokens; the longest possible token
    would be just one entire line.

      To determine where a token ends, your program must determine the
    \textbf{longest} token that matches from a given starting position.  In
    order to do this, it must try to match the input against all of the
    token types, and the longest match is the one that should apply.  In
    order for this process to work the OTHER token must be always be the
    last to be matched against, and it should only match one character.  The
    only exception to the above is the comment token COMM.  Rather than the
    longest token that matches from a given starting position, if it matches
    it always just matches everything up until the end of the input line.

      Examples are:

      \vspace{-2.5mm}

      \begin{itemize}

        \addtolength{\itemsep}{-1mm}

        \item If the input contains just the thirteen characters
              \texttt{intergalactic}, then the token is an ID and contains all
              thirteen characters.  Note that \texttt{int} would be a valid
              KEY, but it is shorter than \texttt{intergalactic}, so the token
              is an ID.

        \item If the input contains just the three characters \texttt{int},
              then the matched token is a KEY and contains all three
              characters.  Note that \texttt{int} is not a valid ID because
              it was stated above that keywords cannot be identifiers.

      \end{itemize}

      \vspace{-4.5mm}

  \section{Development suggestions and hints}

    \begin{itemize}

      \addtolength{\itemsep}{-1mm}

      \item Before starting to code, write a variety of examples of 
            tokens of different forms, according to the definitions above,
            to be sure you have a good understanding of the inputs your
            program will have to process.

      \item Create and store regular expressions for any common syntactic
            elements (syntactic elements that appear in several regular
            expressions in your program) in variables, then use those
            variables in pattern matching operations or in forming other
            regular expressions.  This will not only make your program much
            more readable, but it will be much easier to test, and simpler
            to adjust if you find you need to modify some of your regular
            expressions.  Similarly, even if a regular expression is only
            used once, if it's too large, break it up into smaller ones, and
            test them separately.

      \item Consider using Ruby's \texttt{/x} regular expression option,
            which allows whitespace, newlines, and comments to be included
            in a regular expression for readability.  For example:

            \smallskip

            \begin{centering}

              \begin{BVerbatim}
        /(cat|    # match my favorite pets
          dog)/x
              \end{BVerbatim}

            \end{centering}

            \smallskip

      \item It's suggested that you first write regular expressions
            describing the syntax of the token types (starting with the
            simplest ones first, and testing them before going on)-- which
            may be constructed from other smaller regular expressions as
            mentioned above-- before trying to determine the type of token.
            In other words, initially just write code to test the various
            regular expressions describing the different token types, since
            the rest of your program won't work if these are incorrect,
            before trying to handle the longest match requirement.

      \item Note that if you have a Ruby program that both reads
            command--line arguments and standard input, when you call
            \texttt{gets()} it will try to read values from \texttt{ARGV}.
            The solution would be to either shift \texttt{ARGV} as
            command--line arguments are read, so it's empty before starting
            to read standard input, or, just use a loop of a form like
            \texttt{while (line= STDIN.gets())} to read standard input,
            rather than \texttt{while (line= gets())}.

      \item If you write methods that should return a true or false value,
            remember that a Ruby 0 is not false.

      \item If more than one alternative could match a string in a Ruby regular
            expression using alternation, the leftmost one will be the one
            that does.  For example, in the fragment
            \texttt{"pineapples" =\string~ /(app|store|apple)/}, the
            substring ``app'' of ``pineapples'' will match the regular
            expression, rather than ``apple''.

    \end{itemize}

    \vspace{-4.5mm}

  \section{Project requirements and submitting your project}

    \begin{enumerate}

      \addtolength{\itemsep}{-1mm}

      \item Your program should read all of its input from its standard input
            and write all of its output to its standard output.  Of course in
            UNIX standard input may be redirected from a file, or standard
            output may be redirected to a file.

      \item You may use any Ruby language features in your project that you
            would like, regardless of whether they were covered in class or
            not, so long as your program works successfully using the
            version of Ruby installed on the OIT Grace Cluster and on the
            CMSC project submission server.

      \item Your submitted program file \textbf{must} be in a file named
            ``\texttt{proj1.rb}'', otherwise the submit server will not
            recognize it, consequently its score will be zero.  Although
            Ruby programs can be broken up into multiple source files (not
            shown in class), your program should consist of just this one
            source file.

      \item Your output should match the expected public test outputs
            exactly.  To check this, you can use the UNIX \texttt{diff}
            command.  For example:

            \begin{centering}

              \begin{BVerbatim}
        proj1.rb < public1.input > my-output
        diff my-output public1.output
              \end{BVerbatim}

            \end{centering}

            If no output at all is produced by \texttt{diff}, your output
            matches the expected output and is correct.

      % \item Note that the project grading policy on the class syllabus does
      %       not mention anything about losing credit for warnings, so as long
      %       as your output is correct you will not receive any penalty if your
      %       program produces warning messages.

      \item You aren't required to use the \texttt{-w} option for your
            project, but it is nevertheless recommended, as it will just
            assist you in finding potential bugs.

      \item Your program \textbf{must have} a comment near the top that
            contains your name, TerpConnect login ID (which is your
            directory ID), your university ID number, and your section
            number.

            The Campus Senate has adopted a policy asking students to
            include the following statement on each major assignment in
            every course: ``I pledge on my honor that I have not given or
            received any unauthorized assistance on this assignment.''
            Consequently you're requested to include this pledge in a
            comment near the top of your program source file.  See the next
            section for important information regarding academic integrity.

      \item Note that although you are not being graded on your source code
            or style (see the separate project grading handout), if the TAs
            cannot read or understand your code they cannot help should you
            have to come to office hours, until you return with a
            well--written and clear program.

      \item To submit your program, just type the single command
            \texttt{submit} from the \texttt{proj1} directory that you
            copied above, where your program file \texttt{proj1.rb} should
            be.  You will have to enter your UMCP directory ID and password.
            Then log into the submit server to verify that your submission
            worked there.

    \end{enumerate}

    \vspace{-4.5mm}

  \section{Example}

    \vspace{-4.5mm}

    {

      \setlength{\columnsep}{-70mm}

      \begin{multicols}{2}

        \noindent
        The output below was produced by running the program with input
      redirected from the file shown on the right.  Try storing your
      programs' output such as this in a file with the extension
      \texttt{.html} and displaying it in your web browser.

        Note that the tokens in this example just happened to be arranged in
      the form of a valid Java class, just for clarity, but that may not be
      the case in all inputs your program has to process.  In fact, it's
      more likely that its input will just be a random sequence of Java
      tokens.  Your program should not attempt to check whether the tokens
      in its input are in the form of a valid Java class; this would require
      parsing techniques that have not been covered.

      \columnbreak

      \hspace{\fill}
      \begin{minipage}[t]{1.85in}

        \VerbatimInput[gobble=0,frame=single,formatcom=\small]{example}

      \end{minipage}

    \end{multicols}

    }

    \vspace{-2mm}

    \begin{minipage}[t]{7.2in}

      \VerbatimInput[gobble=0,frame=single,formatcom=\footnotesize]
                    {example-output.html}

    \end{minipage}

    \medskip\smallskip

  \section{Academic integrity}

    Please \textbf{carefully read} the academic honesty section of the course
  syllabus.  \textbf{Any evidence} of impermissible cooperation on projects,
  use of disallowed materials or resources, or unauthorized use of computer
  accounts, \textbf{will be submitted} to the Student Honor Council, which
  could result in an XF for the course, or suspension or expulsion from the
  University.  Be sure you understand what you are and what you are not
  permitted to do in regards to academic integrity when it comes to project
  assignments.  These policies apply to all students, and the Student Honor
  Council does not consider lack of knowledge of the policies to be a
  defense for violating them.  Full information is found in the course
  syllabus-- please review it at this time.

\end{document}
