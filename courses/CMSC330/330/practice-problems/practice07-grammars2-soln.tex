\documentclass[11pt]{article}

  \usepackage{330-f12}

\begin{document}

  \header{\course}
         {
           \begin{tabular}[t]{@{}c@{}}
             Using grammars for programming languages--
             \\
             solutions
           \end{tabular}
         }
         {\Term}

    \vspace{-2mm}

  \begin{enumerate}

    \addtolength{\itemsep}{8mm}

    \item There are different ways to write the grammars correctly.

          (Long nonterminal names, like those used in some of the solutions
           here, are fine in general and can be helpful since they are more
           descriptive, but in an exam situation you might prefer to use
           short single--letter nonterminal names in order to be able to
           write answers more quickly.)

          \vspace{-3mm}

          \begin{enumerate}

            \addtolength{\itemsep}{4mm}

            \item \newcommand{\binaryformula}{\ensuremath{<\!\!
                                            \mathrm{binary\!-\!formula} \!\!>}}
                  \newcommand{\unaryformula}{\ensuremath{<\!\!
                                             \mathrm{unary\!-\!formula} \!\!>}}
                  \newcommand{\operand}{\ensuremath{<\!\!
                                          \mathrm{operand} \!\!>}}

                  \(
                    \renewcommand{\arraystretch}{1.25}
                    \begin{array}[t]{@{}l@{\hspace{2mm}}l@{\hspace{2mm}}l}
                      \binaryformula
                        & ::=
                        & \unaryformula \ \rightarrow \
                          \binaryformula \midspc \unaryformula
                          \\
                      \unaryformula
                        & ::=
                        & \sim \unaryformula \midspc \:
                          \lpar \binaryformula \rpar \: \midspc \operand
                        \\
                      \operand
                        & ::=
                        & \mathtt{p} \midspc \mathtt{q}
                        \\
                    \end{array}
                  \)

            \item \newcommand{\binaryexpr}{\ensuremath{<\!\!
                                          \mathrm{binary\!-\!expr} \!\!>}}
                  \newcommand{\unaryexpr}{\ensuremath{<\!\!
                                          \mathrm{unary\!-\!expr} \!\!>}}
                  \newcommand{\postfixexpr}{\ensuremath{<\!\!
                                            \mathrm{postfix\!-\!expr} \!\!>}}
                  \newcommand{\id}{\ensuremath{<\!\! \mathrm{id} \!\!>}}

                  \(
                    \renewcommand{\arraystretch}{1.25}
                    \begin{array}[t]{@{}l@{\hspace{2mm}}l@{\hspace{2mm}}l}
                      \binaryexpr
                        & ::=
                        & \binaryexpr \ \verb@->@ \
                          \unaryexpr \midspc \unaryexpr
                          \\
                      \unaryexpr
                        & ::=
                        & \verb@*@ \unaryexpr \midspc \postfixexpr
                        \\
                      \postfixexpr
                        & ::=
                        & \postfixexpr\verb@++@ \midspc \id
                        \\
                      \id
                        & ::=
                        & \mathtt{a \midspc b}
                        \\
                    \end{array}
                  \)

            \item \newcommand{\aplexpr}{\ensuremath{<\!\!
                                        \mathrm{apl\!-\!expr} \!\!>}}
                  \newcommand{\aploperand}{\ensuremath{<\!\!
                                           \mathrm{operand} \!\!>}}

                  \(
                    \renewcommand{\arraystretch}{1.25}
                    \begin{array}[t]{@{}l@{\hspace{2mm}}l@{\hspace{2mm}}l}
                      \aplexpr
                        & ::=
                        & + \aplexpr \midspc - \aplexpr \midspc
                          * \aplexpr \midspc / \aplexpr \midspc
                          \\
                      %
                        & %
                        & \aploperand + \aplexpr \midspc
                          \aploperand - \aplexpr \midspc
                          \\
                      %
                        & %
                        & %
                          \aploperand * \aplexpr \midspc
                          \aploperand / \aplexpr \midspc \aploperand
                          \\
                      \aploperand
                        & ::=
                        & \mathtt{a} \midspc \mathtt{b} \midspc
                          \mathtt{c} \midspc \: \lpar \aplexpr \rpar
                          \\
                    \end{array}
                  \)

            \item Note that the first vertical bar in the productions for S
                  is the \texttt{|} operator, not the vertical bar
                  separating the right sides of the different productions
                  for S.

                  \medskip

                  \begin{grammar}[1.35]

                    \production{S}{S \ \texttt{|} \ T \midspc T}
                      \\

                    \production{T}{T \ \texttt{\string^} \ U \midspc U}
                      \\

                    \production{U}{U \ \texttt{\&} \ V \midspc V}
                      \\

                    \production{V}{V \ \texttt{<<} \ W \midspc
                                   V \ \texttt{>>} \ W \midspc W}
                      \\

                    \production{W}{\texttt{~}W \midspc X}
                      \\

                    \production{X}{\texttt{n} \midspc \texttt{(}S\texttt{)}}
                      \\

                  \end{grammar}

            \item \begin{grammar}[1.35]

                    \production{S}{T \ \texttt{|} \ S \midspc T}
                      \\

                    \production{T}{U \ \texttt{\string^} \ T \midspc U}
                      \\

                    \production{U}{V \ \texttt{\&} \ U \midspc V}
                      \\

                    \production{V}{W \ \texttt{<<} \ V \midspc
                                   W \ \texttt{>>} \ V \midspc W}
                      \\

                    \production{W}{\texttt{~}W \midspc X}
                      \\

                    \production{X}{\texttt{n} \midspc \texttt{(}S\texttt{)}}
                      \\

                  \end{grammar}

            \item \begin{grammar}[1.35]

                    \production{S}{S \ \texttt{|} \ T \midspc T}
                      \\

                    \production{T}{T \ \texttt{\string^} \ U \midspc U}
                      \\

                    \production{U}{U \ \texttt{\&} \ V \midspc V}
                      \\

                    \production{V}{V \ \texttt{<<} \ Y \midspc
                                   V \ \texttt{>>} \ Y \midspc W}
                      \\

                    \production{W}{\texttt{~}W \midspc X}
                      \\

                    \production{X}{\texttt{n} \midspc \texttt{(}S\texttt{)}}
                      \\

                    \production{Y}{\texttt{0xF} \midspc \texttt{0x1}}

                  \end{grammar}

            \item \begin{grammar}[1.35]

                     \production{S}{\texttt{a}T}
                       \\

                     \production{T}{T\texttt{[n]} \midspc
                                    T\texttt{[}S\texttt{]} \midspc
                                    \texttt{[n]} \midspc
                                    \texttt{[}S\texttt{]}}
                       \\

                  \end{grammar}

            \item \begin{grammar}[1.35]

                     \production{S}{S \ \texttt{<} \ V \midspc
                                    S \ \texttt{>} \ V \midspc
                                    S \ \texttt{==} \ V \midspc T}
                       \\

                     \production{T}{\texttt{x} \ \texttt{=} \ T \midspc
                                    \texttt{y} \ \texttt{=} \ T \midspc
                                    \texttt{z} \ \texttt{=} \ T \midspc U}
                       \\

                     \production{U}{V \ \texttt{\string^} \ U \midspc V}
                       \\

                     \production{V}{\texttt{(}S\texttt{)} \midspc \texttt{x}
                                    \midspc \texttt{y} \midspc \texttt{z}
                                    \midspc \texttt{x++} \midspc
                                    \texttt{y++} \midspc \texttt{z++}}
                       \\

                  \end{grammar}

          \end{enumerate}

          \medskip

    \item Both these grammars cure the ambiguity.  The first uses the
          \texttt{end} ending an \texttt{if} statement to allow an
          \texttt{else} to be correctly associated with the proper
          \texttt{if} statement.

          The second grammar also cures the problem, by requiring the
          \texttt{then} part of the \texttt{if} statement to be surrounded
          by a \texttt{begin}/\texttt{end} pair.

          The best way to see this is to try derivations with grammar of some
          string that has an \texttt{if} statement containing a nested
          \texttt{if} statement with an \texttt{else} part, and convince
          yourself there is only one derivation possible for it in each of
          these grammars.

          Note that these grammars solve the dangling \texttt{else} problem
          by requiring that extra keywords (\texttt{end} or \texttt{begin}
          and \texttt{end}) be added to some or all \texttt{if} statements.

    \item \begin{enumerate}

            \item \(
                    \begin{array}[t]{@{}l@{\hspace{2mm}}l@{\hspace{2mm}}l}
                      \NT{start}
                        & ::=
                        & \mathtt{\texttt{(} \ define \ \: \textrm{f} \
                          \texttt{(} \ \NT{mid} \ \texttt{)}}
                        \\
                      \NT{mid}
                        & ::=
                        & \mathtt{\NT{formal} \ \NT{mid} \ \NT{actual} \
                          \midspc \ \texttt{)} \ \NT{body} \ \texttt{)} \
                          \texttt{(} \ \mathrm{f}}
                        \\
                      \NT{formal}
                        & ::=
                        & \NT{id}
                        \\
                      \NT{actual}
                        & ::=
                        & \NT{expr}
                        \\
                      \NT{body}
                        & ::=
                        & \ldots
                        \\
                      \NT{id}
                        & ::=
                        & \ldots
                        \\
                      \NT{expr}
                        & ::=
                        & \ldots
                        \\
                    \end{array}
                  \)

                  \medskip

                  The idea behind the grammar is that it matches the first
                  formal parameter in the function's definition with the
                  last actual parameter in the function's call, the second
                  formal parameter in the function's definition with the
                  second--to--last actual parameter in the call, etc.  You
                  can see that it works by deriving a program in which the
                  function \texttt{f} has no parameters and the call has no
                  arguments, a program in which the function \texttt{f} has
                  one parameter and the call has one argument, and a program
                  in which the function \texttt{f} has several parameters
                  and the call has several arguments.

            \item This approach wouldn't work correctly for more than one
                  function call.  As a matter of fact, it is not possible to
                  do this sort of match with a context free grammar (CFG),
                  since a CFG cannot match arbitrarily many symbols.  For
                  example, although we will not prove this, the language
                  \(
                    \mathrm{
                      L \: = \: \{ \,
                        {\mathit{a}^n}{\mathit{b}^n}{\mathit{c}^n} \: \mid
                          \: n \: \geq \: 0 \,\}
                    }
                  \)
                  is not a context--free language (if you tried, you could
                  never come up with a CFG generating it).  And this is the
                  formal language that essentially describes matching
                  exactly two function calls with one function definition.

                  So although grammars are used to describe
                  programming--language syntax when writing a compiler, some
                  syntactic requirements must be enforced through some means
                  other than a grammar.  In fact, a later phase of a
                  compiler checks properties like this that can't be
                  captured in a CFG.

          \end{enumerate}

    % \item \setlength{\columnsep}{8mm}
    %
    %       \raggedcolumns
    %
    %       \begin{multicols}{2}
    %
    %         \begin{enumerate}
    %
    %           \addtolength{\itemsep}{6mm}
    %
    %           \item First create the following DFA, and use it and the
    %                 procedure or construction given in class to generate the
    %                 grammar.  A is the start symbol.
    %
    %                 \begin{automaton}(0,0)(42,39)
    %
    %                   \state[start,label=A](10,30){A}
    %                   \state[label=B](35,30){B}
    %                   \state[label=C](10,5){C}
    %                   \state[final,label=D](35,5){D}
    %
    %                   \transition[offset=2](A,\emph{a},B)
    %                   \transition[offset=-2,labellocation=below](A,\emph{b},C)
    %
    %                   \transition[offset=2](B,\emph{a},A)
    %                   \transition[offset=-2,labellocation=below](B,\emph{b},D)
    %
    %                   \transition[offset=2](C,\emph{a},D)
    %                   \transition[offset=-2,labellocation=below](C,\emph{b},A)
    %
    %                   \transition[offset=2](D,\emph{a},C)
    %                   \transition[offset=-2,labellocation=below](D,\emph{b},B)
    %
    %                 \end{automaton}
    %
    %                 \bigskip\bigskip
    %
    %                 \begin{grammar}
    %                   \production{A}{\mathit{a}B \midspc \mathit{b}C}
    %                     \\
    %                   \production{B}{\mathit{a\mathrm{A} \midspc
    %                                  b\mathrm{D} \midspc b}}
    %                     \\
    %                   \production{C}{\mathit{b\mathrm{A} \midspc
    %                                  a\mathrm{D} \midspc a}}
    %                     \\
    %                   \production{D}{\mathit{a}C \midspc \mathit{b}B}
    %                     \\
    %                 \end{grammar}
    %
    %           \item First create the following DFA, and use it and the
    %                 procedure given in class to generate the grammar.
    %                 $\mathrm{S'}$ is the start symbol.
    %
    %                 \bigskip
    %
    %                 \begin{automaton}(0,0)(60,31)
    %
    %                   \state[start,final,label=S](10,15){S}
    %                   \state[final,label=T](35,15){T}
    %                   \state[final,label=U](60,15){U}
    %
    %                   \transition(S,\emph{a},T)
    %                   \transition(S,\emph{b},S)
    %
    %                   \transition(T,\emph{a},T)
    %                   \transition(T,\emph{b},U)
    %
    %                   \transition(U,\emph{a},U)
    %                   \transition[loopdirection=down](U,\emph{b},U)
    %
    %                 \end{automaton}
    %
    %                 \vspace{-4mm}
    %
    %                 \begin{tabular}[t]{@{}p{1.15in}@{\hspace{4mm}}p{1.61in}@{}}
    %
    %                   \begin{tabular}[b]{@{}l@{}}
    %
    %                     \begin{grammar}
    %                       \production{S'}{S \midspc \epsilon}
    %                         \\
    %                       \production{S}{\mathit{a}T \midspc \mathit{a}}
    %                         \\
    %                       \production{S}{\mathit{b}S \midspc \mathit{b}}
    %                         \\
    %                       \production{T}{\mathit{a}T \midspc \mathit{a}}
    %                         \\
    %                       \production{T}{\mathit{b}U}
    %                         \\
    %                       \production{U}{\mathit{a}U \midspc \mathit{b}U}
    %                         \\
    %                     \end{grammar}
    %
    %                   \end{tabular}
    %
    %                 &
    %
    %                   \vspace{\fill}
    %
    %                   Rewriting:
    %
    %                   \medskip
    %
    %                   \begin{tabular}[b]{@{}l@{}}
    %
    %                     \begin{grammar}
    %                       \production{S'}{S \midspc \epsilon}
    %                         \\
    %                       \production{S}{\mathit{a}T \midspc \mathit{a} \midspc
    %                                      \mathit{b}S \midspc \mathit{b}}
    %                         \\
    %                       \production{T}{\mathit{a}T \midspc \mathit{a} \midspc
    %                                      \mathit{b}U}
    %                         \\
    %                       \production{U}{\mathit{a}U \midspc \mathit{b}U}
    %                         \\
    %                     \end{grammar}
    %
    %                   \end{tabular}
    %
    %                 \end{tabular}
    %
    %                 Note that the productions for the nonterminal U are dead
    %                 productions, meaning they can't produce a string of
    %                 terminals (corresponding to the dead state in the DFA).
    %                 This is the grammar that would result from automatically
    %                 applying the procedure given in class; an equivalent
    %                 grammar that would generate the same language would
    %                 consist of just the first four rules above and not the
    %                 last two (i.e., simplifying the grammar by omitting its
    %                 dead productions).
    %
    %           \item First create the following DFA, and use it and the
    %                 procedure given in class to generate the grammar.
    %                 $\mathrm{S'}$ is the start symbol.
    %
    %                 \medskip
    %
    %                 \hspace{-4mm}%
    %                 \begin{automaton}(0,0)(70,31)
    %
    %                   \state[start,final,label=S](10,15){S}
    %                   \state[final,label=T](30,15){T}
    %                   \state[label=U](50,15){U}
    %                   \state[label=V](70,15){V}
    %
    %                   \transition[offset=2](S,\emph{a},T)
    %                   \transition(S,\emph{b},S)
    %
    %                   \transition(T,\emph{a},U)
    %                   \transition[offset=2](T,\emph{b},S)
    %
    %                   \transition(U,\emph{a},V)
    %                   \transition[curved,loopdirection=down,angle=52]%
    %                               (U,\emph{b},S)
    %
    %                   \transition(V,\emph{a},V)
    %                   \transition[loopdirection=down](V,\emph{b},V)
    %
    %                 \end{automaton}
    %
    %                 \smallskip
    %
    %                 \begin{grammar}
    %                   \production{S'}{S \midspc \epsilon}
    %                     \\
    %                   \production{S}{\mathit{a\mathrm{T} \midspc a \midspc
    %                                  b\mathrm{S} \midspc b}}
    %                     \\
    %                   \production{T}{\mathit{a\mathrm{U} \midspc
    %                                  b\mathrm{S} \midspc b}}
    %                     \\
    %                   \production{U}{\mathit{a}V \midspc \mathit{b}S \midspc
    %                                  \mathit{b}}
    %                     \\
    %                   \production{V}{\mathit{a}V \midspc \mathit{b}V}
    %                     \\
    %                 \end{grammar}
    %
    %                 \medskip
    %
    %                 Again, the productions from nonterminal V are dead
    %                 productions (so are the productions that generate a V).
    %
    %         \end{enumerate}
    %
    %       \end{multicols}

  \end{enumerate}

\end{document}
