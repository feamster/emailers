\documentclass[11pt]{article}

  \usepackage{330-f12}

\begin{document}

  \header{\course}{Using grammars for programming languages}{\Term}

  \vspace{-3mm}

  \begin{enumerate}

    \addtolength{\itemsep}{5mm}

    \item Grammars can be used to express concepts like associativity and
          precedence of operators.  For each of the following languages,
          give unambiguous grammars capturing the appropriate associativity
          and precedence.

          \vspace{-2mm}

          \begin{enumerate}

            \addtolength{\itemsep}{3mm}

            \item Propositional calculus formulas having operators unary
                  $\sim$ (negation) and binary $\rightarrow$ (implication),
                  operands \texttt{p} and \texttt{q}, and parentheses.  The
                  operators should both be right associative and have their
                  usual precedence, which is that $\sim$ has higher
                  precedence than $\rightarrow$.

            \item C expressions with identifiers \texttt{a} and \texttt{b}
                  and operators \verb@->@, \texttt{*}, and \texttt{++}.
                  \verb@->@ is a left associative binary operator,
                  \texttt{*} is a right associative unary prefix operator,
                  and \texttt{++} is a left associative unary postfix
                  operator.  The prefix \texttt{*} operator has a lower
                  precedence than the postfix \texttt{++} operator, but
                  higher than the binary \verb@->@ operator.  For example,
                  the expression \texttt{*a++} increments \texttt{a} before
                  dereferencing it.

            \item Operators in APL are right associative and have equal
                  precedence, unless altered by parentheses.  The operators
                  +, $-$, *, / can appear as both monadic (unary) and dyadic
                  (binary) operators.  Assignment ($\leftarrow$) is also
                  treated as a binary operator that returns the value
                  assigned as its result.  Write an unambiguous context free
                  grammar for APL expressions containing the operands
                  \texttt{a}, \texttt{b}, and \texttt{c}.

                  Since the operators all have the same precedence, make
                  sure your grammar gives the correct interpretation to an
                  expression such as for example $- \mathtt{a} + \mathtt{b}$,
                  which according to the above would be (unlike in
                  conventional arithmetic and languages you have seen)
                  $- ( \mathtt{a} + \mathtt{b} )$.

            \item In C the binary bitwise and shift operators \texttt{<<},
                  \texttt{>>}, \texttt{\&}, \texttt{\string^}, and
                  \texttt{\string|} are all left--associative.  The unary
                  prefix operator \texttt{\~} is right--associative.  Their
                  precedence is as follows:

                  \vspace{-1mm}

                  \begin{center}

                    \begin{tabular}[t]{cl}

                      \texttt{\~}
                        & highest prededence
                        \\

                      \texttt{<<} and \texttt{>>}
                        & next highest precedence (these have the same
                          precedence)
                        \\

                      \texttt{\&}
                        & next highest precedence
                        \\

                      \texttt{\string^}
                        & next highest precedence
                        \\

                      \texttt{\string|}
                        & lowest precedence
                        \\

                    \end{tabular}

                  \end{center}

                  \smallskip

                  Parentheses may also be used in expressions using these
                  operators, and may be thought of as operators having the
                  highest precedence.

                  Write an unambiguous context--free grammar that generates
                  all valid C expressions using these operators, assuming
                  the only valid operand is a variable named \texttt{n}.

            \item Repeat the previous problem now assuming that all of the
                  binary operators mentioned are right--associative instead
                  of left--associative.

            \item Repeat part (d) now assuming that the right operand of the
                  shift operators \texttt{<<} and \texttt{>>} can only be
                  either the constant \texttt{0xF} or \texttt{0x1}.  The
                  left operand of the shift operators, and the operands of
                  the other operators, may be either \texttt{n} or any
                  valid subexpression formed using any operators.

            \item Write an unambiguous context--free grammar that generates
                  certain array element references in C or Java.  Array
                  element references may be single dimensional or
                  multidimensional.  The only valid array name is
                  \texttt{a}.  An array name is followed by one or more
                  subscripts, which are square braces (\texttt{[]})
                  surrounding either the variable \texttt{n}, or another
                  array reference.  (Note that parentheses are not allowed
                  in array element references in this problem.)  Some
                  valid array references would be:

                  \begin{center}

                    \begin{tabular}[t]{l}

                      \texttt{a[n]}
                        \\

                      \texttt{a[n][n]}
                        \\

                      \texttt{a[a[n]]}
                        \\

                      \texttt{a[n][a[n]][a[a[n][n]a[n]][n]}
                        \\

                    \end{tabular}

                  \end{center}

                  If an array is multidimensional your grammar must give the
                  interpretation that the subscripts are grouped from
                  \textbf{left to right}.

            \item \texttt{bc} is a UNIX calculator utility; you can run
                  \texttt{bc} and type in expressions to be evaluated,
                  including assignments to variables, function definitions,
                  etc.  Write an unambiguous context--free grammar
                  generating a small subset of valid \texttt{bc} expressions
                  using the following operators, which are listed in order
                  of \textbf{decreasing precedence}:

                  \vspace{-2mm}

                  \begin{center}

                    \begin{tabular}[t]{cp{5in}}

                      \texttt{++}
                        & the postfix unary increment operator is
                          \textbf{nonassociative}
                        \\

                      \texttt{\string^}
                        & the binary exponentation operator is
                          right--associative
                        \\

                      \texttt{=}
                        & the assignment operator is right--associative
                        \\

                      \texttt{<}, \texttt{>}, and \texttt{==}
                        & these three comparison operators have the same
                          precedence and are left--associative
                        \\

                    \end{tabular}

                  \end{center}

                  The only valid variable names are \texttt{x}, \texttt{y}
                  and \texttt{z}.  Parentheses may also be used in
                  expressions using these operators, and may be thought of
                  as operators having the highest precedence.

                  Saying that the \texttt{++} operator is nonassociative
                  means that multiple occurrences of this operator cannot be
                  applied in sequence.  (It can only be applied to an
                  lvalue, but it returns an rvalue, so it cannot be applied
                  to its result.)  For example, \texttt{x++} is valid but
                  \texttt{x++++} is not.

                  Note that the left operand of any assignment must just be
                  a \textbf{single variable name}.  The right operand of an
                  assignment, and the operands of the other operators (other
                  than \texttt{++} as mentioned above), may be either
                  \texttt{x} or \texttt{y}, or any valid subexpression
                  formed using any operators.  Since the assignment operator
                  is associative it may be applied in sequence, but only a
                  variable name may appear on the left side of an
                  assignment.  For example, the expression \texttt{x = y =
                  x++ << x} is valid, but \texttt{x++ = y} and \texttt{x =
                  y \string^ x = x} are not.

                  Lastly note that the operators' precedence means that an
                  expression like \texttt{x = y < z} should have the
                  interpretation \texttt{(x = y) < z} (\texttt{y} is
                  assigned to \texttt{x},  and the result of the assignment
                  is compared to \texttt{z}), not \texttt{x = (y <
                  z)} as you might expect (which is what the expression
                  would mean in C or Java, for example).

          \end{enumerate}

    \item In lecture an ambiguous grammar for \texttt{if} statments was
          shown, in which it was impossible to conclude which of two nested
          \texttt{if} statments an \texttt{else} belonged to (the ``dangling
          else'' problem).  Consider the two grammars below (written using
          BNF notation).  Does each grammar cure the dangling else problem
          by eliminating the ambiguity of which \texttt{if} statement an
          \texttt{else} part is associated with?  Assume in both cases that
          the only valid boolean expression consists of the single boolean
          variable \texttt{b}, and the only valid statement consists of the
          terminal string \texttt{skip} (obviously we could extend the
          grammars with more realistic productions, but it would just make
          the problem longer and not really be germane).

          \vspace{-1.5mm}

          \begin{enumerate}

            \addtolength{\itemsep}{.75mm}

            \item \begin{tabular}[t]{lll}

                    \NT{stmtlist}  & ::= & \NT{stmtlist} \texttt{;} \NT{stmt}
                                         $\mid$ \NT{stmt} \\

                    \NT{stmt}      & ::= & \NT{if stmt} $\mid$ \texttt{skip} \\

                    \NT{if stmt}   & ::= & \texttt{if b then} \NT{stmtlist}
                                          \NT{else part} \texttt{end} \\

                    \NT{else part} & ::= & \texttt{else} \NT{stmtlist} $\mid \
                                           \epsilon $ \\

                  \end{tabular}

                  \smallskip

            \item \begin{tabular}[t]{lll}

                    \NT{stmt}     & ::= & \NT{ustmt} $\mid$ \NT{cstmt} \\

                    \NT{ustmt}    & ::= & \texttt{skip} $\mid$ \texttt{begin}
                                          \NT{stmtlist} \texttt{end} \\

                    \NT{cstmt}    & ::= & \texttt{if b then} \NT{ustmt}
                                          \texttt{else} \NT{stmt} $\mid$
                                          \texttt{if b then} \NT{ustmt} \\

                    \NT{stmtlist} & ::= & \NT{stmtlist} \texttt{;} \NT{stmt}
                                          $\mid$ \NT{stmt} \\

                  \end{tabular}

                  \medskip

                  Note that \NT{ustmt} represents an
                  unconditionally--executed statement, while \NT{cstmt}
                  represents a conditionally--executed statement.

          \end{enumerate}

    \item Context-free grammars cannot express all the syntactic
          restrictions normally placed on programming languages; for
          instance one example is that all function calls must have the same
          number of actual parameters as the number of formal parameters in
          the function's definition.  Consider a Scheme--like language that
          permits a definition of a single function \texttt{f} followed by a
          single call to it (each with an arbitrary number of parameters)
          defined by the grammar below.  (Note that every expression in
          Scheme is surrounded by parentheses.)

          \smallskip

          \begin{tabular}{lll}

            \NT{program}
              & ::=
              & \texttt{( define f (} \NT{formals} \texttt{)} \NT{body}
                \texttt{) ( f} \NT{actuals} \texttt{)}
              \\

            \NT{formals} & ::= & \NT{formals} \NT{id} \ $\midspc\ \epsilon$ \\

            \NT{actuals} & ::= & \NT{actuals} \NT{expr} \ $\midspc \
                                 \epsilon$ \\

            \NT{body}    & ::= & ... \\

            \NT{id}      & ::= & ... \\

            \NT{expr}    & ::= & ... \\

          \end{tabular}

          \smallskip

          The expression \texttt{( define f ( \NT{formals} ) \NT{body} )} is
          the definition of a function \texttt{f} with parameter list
          \NT{formals} and body \NT{body}, while the following expression
          \texttt{( f \NT{actuals} )} is a following call to \texttt{f} with
          actual parameters \NT{actuals}.  Productions for \NT{body},
          \NT{id} and \NT{expr} aren't given; you should assume that they
          derive the body of a function (a list of expressions), an
          identifier, and an expression respectively.  As above, this
          grammar generates small programs that consist of only a single
          definition of one function, followed by a single call to it.

          The problem with this grammar is that it derives programs
          (consisting of a function definition followed by a call) where the
          call to the function \texttt{f} has a different number of
          arguments than the definition of the function \texttt{f} has
          parameters.  For example, you can verify that the following can be
          derived from the start symbol \NT{program}; this is a case where
          \texttt{f} is defined to have two formal parameters but is then
          called with only one actual parameter: \texttt{( define f (
          \NT{id} \NT{d} ) \NT{body} ) ( f \NT{id} )}.

          \vspace{-2mm}

          \begin{enumerate}

            \addtolength{\itemsep}{1mm}

            \item Develop another grammar for this language that enforces
                  the restriction that a call to \texttt{f} must have the
                  same number of arguments as there are formal parameters in
                  its definition.  As above, you can treat \NT{body},
                  \NT{id} and \NT{expr} as nonterminals.

            \item Determine whether it is possible to generalize the
                  approach in part (a) to a language in which arbitrarily
                  many calls to a procedure or function can occur.  In other
                  words, can your grammar from part (a) be adjusted to allow
                  multiple calls to \texttt{f} following the definition of
                  \texttt{f}, where each call has the same number of actual
                  parameters as the number of formal parameters in the
                  definition of \texttt{f}?

          \end{enumerate}

    % \item Write unambiguous grammars for the following languages:
    %
    %       \vspace{-1mm}
    %
    %       \begin{enumerate}
    %
    %         \addtolength{\itemsep}{2mm}
    %
    %         \item \(
    %                 \{ \,
    %                   w \midspc w \: \in \: \{a,b\}^* \
    %                   \textrm{and} \
    %                   w \
    %                   \textrm{has an odd number of} \
    %                   a\textrm{'s} \
    %                   \textrm{and an odd number of} \ b\textrm{'s}
    %                 \, \}
    %               \)
    %
    %         \item \(
    %                 \{ \,
    %                   w \midspc w \: \in \: \{a,b\}^* \ \mathrm{and} \ w \
    %                   \textrm{contains no substrings of the form} \ ab
    %                 \, \}
    %               \)
    %
    %         \item \(
    %                 \{ \,
    %                   w \midspc w \: \in \: \{a,b\}^* \
    %                   \textrm{and every pair of} \
    %                   a\textrm{'s} \ \mathrm{in} \ w \
    %                   \textrm{is followed by at least one} \ b
    %                 \, \}
    %               \)
    %
    %       \end{enumerate}

  \end{enumerate}

\end{document}
