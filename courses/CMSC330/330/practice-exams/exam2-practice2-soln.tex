\documentclass[11pt]{article}

  \usepackage{330-f12}

  \usepackage{pst-tree}

  \psset{unit=1mm,levelsep=12,treesep=10,nodesep=1.5}

\begin{document}

  \header{\course}{Exam \#2 practice questions \#2-- solutions}{\Term}

  \begin{enumerate}

    \addtolength{\itemsep}{10mm}

    \item \begin{enumerate}

            \addtolength{\itemsep}{4mm}

            \item \begin{enumerate}

                    \addtolength{\itemsep}{2mm}

                    \item \verb@let f x y = (x, x, y)@

                    \item \verb@let f x y z = y (x z)@

                    \item \verb@let rec f x = f x@

                          \smallskip

                          Notice that because \texttt{f} never terminates,
                          its result type could be anything.

                  \end{enumerate}

            \item Shadowing occurs when one name hides another name that
                  would otherwise be in scope.  For example, in OCaml, the
                  inner \texttt{x} shadows the outer \texttt{x} in the
                  following function:

                  \vspace{-1mm}

                  \begin{center}

                    \verb@let f x = (fun x -> x + x)@

                  \end{center}

                  \medskip

                  Here's an example in C:\hspace{1mm}

                  \vspace{-4mm}

                  \begin{center}

                    \begin{BVerbatim}
        void f(int x) {
          int x = 3;

          x = x + x;
        }
                    \end{BVerbatim}

                  \end{center}

                  % See the lecture slides for more examples.

            \item Yes.  \texttt{$e_1$ \&\& $e_2$} is short-circuiting and
                  won't evaluate $e_2$ if $e_1$ is false.  But functions are
                  call--by--value, so \texttt{and($e_1$, $e_2$)} will always
                  evaluate both $e_1$ and $e_2$.  For example, suppose we
                  define \verb@int f(void) { printf("hello"); return 3; }@.
                  Then \verb@0 && f(x)@ will not print anything, but
                  \texttt{and(0, f(x))} will.

          \end{enumerate}

    \item % \begin{enumerate}
          %
          %   \addtolength{\itemsep}{2mm}
          %
          %   \item
          There are two sources of ambiguity in this grammar.  One is the
          production \production{S}{S \ S}, the other is the production
          \production{T}{T \rightarrow T}.

                  Ambiguity could be demonstrated by showing two leftmost or
                  two rightmost derivations for the same string (using
                  either source of ambiguity), or two parse trees for the
                  same string (which may have been quicker than writing two
                  derivations).

                  Here is one ambiguity, shown by having two parse trees
                  for the same string ``x y z'':

                  \vspace{-2mm}

                  \begin{multicols}{2}

                    \begin{center}

                      \pstree{\TR{S}}{
                        \pstree{\TR{S}}{
                          \pstree{\TR{S}}{
                            \pstree{\TR{x}}{
                            }
                          }
                          \pstree{\TR{S}}{
                            \pstree{\TR{y}}{
                            }
                          }
                        }
                        \pstree{\TR{S}}{
                          \pstree{\TR{z}}{
                          }
                        }
                      }

                    \end{center}

                    \begin{center}

                      \pstree{\TR{S}}{
                        \pstree{\TR{S}}{
                          \pstree{\TR{x}}{
                          }
                        }
                        \pstree{\TR{S}}{
                          \pstree{\TR{S}}{
                            \pstree{\TR{y}}{
                            }
                          }
                          \pstree{\TR{S}}{
                            \pstree{\TR{z}}{
                            }
                          }
                        }
                      }

                    \end{center}

                  \end{multicols}

                  \vspace{-10mm}

                  Two leftmost or two rightmost derivations could be shown
                  for the same string, or for any other ambiguous string,
                  as well.  The two leftmost derivations for this string
                  are:

                  \smallskip

                  \(
                    \mathrm{S} \Longrightarrow \mathrm{S \ S}
                    \Longrightarrow \mathrm{S \ S \ S} \Longrightarrow x \
                    \mathrm{S \ S} \Longrightarrow x \ y \ \mathrm{S}
                    \Longrightarrow x \ y \ z
                  \)

                  \smallskip

                  and

                  \smallskip

                  \(
                    \mathrm{S} \Longrightarrow \mathrm{S \ S}
                    \Longrightarrow x \ \mathrm{S} \Longrightarrow x \
                    \mathrm{S \ S} \Longrightarrow x \ y \ \mathrm{S}
                    \Longrightarrow x \ y \ z
                  \)

          %   \item It turned out that the second requirement above, that
          %         function definitions extend as far to the right as
          %         possible, is a little tricky to enforce, so we just
          %         ignored it in grading, and only required that your answer
          %         be unambiguous and enforce function application to be
          %         left--associative and function types to be
          %         right--associative.  Here's a correct solution:
          %
          %         \smallskip
          %
          %         \begin{grammar}[1.35]
          %           \production[::=]{S}{T \; U \midspc T \midspc U}
          %             \\
          %           \production[::=]{T}{T \; W  \midspc W}
          %             \\
          %           \production[::=]{U}{\lambda X\!:\!V.S}
          %             \\
          %           \production[::=]{V}{\mathtt{int} \midspc \mathtt{int} \,
          %                               \rightarrow \, V}
          %             \\
          %           \production[::=]{W}{\mathtt{1} \midspc \mathtt{2} \midspc
          %                               \mathtt{3} \midspc X}
          %             \\
          %           \production[::=]{X}{\mathtt{x} \midspc \mathtt{y} \midspc
          %                               \mathtt{z}}
          %             \\
          %         \end{grammar}
          %
          % \end{enumerate}

          \pagebreak

    \item Here is one solution:

          \begin{Verbatim}
        (* returns the value corresponding to the first occurrence of n in
           association list *)
        let rec lookup n = function
            [] -> raise Not_found  (* optional *)
          | ((k, v)::t) -> if n = k then v else lookup v t

        let v = ref []

        let eval_instr = function
            (s, IConst x) -> x::s
          | (x::y::s, IAdd) -> (x + y)::s
          | (x::s, Dup) -> x::x::s
          | (s, Nop) -> s
          | (x::s, Pop) -> s
          | (x::y::s, Swap) -> y::x::s
          | (s, ILoad n) -> (lookup n (!v))::s
          | (x::s, IStore n) ->
              begin
                v := (n, x)::(!v);  (* add new value of n *)
                s                   (* evaluate to result stack *)
              end

        let rec eval = function
            (s, []) -> s
          | (s, i::is) -> eval (eval_instr (s, i), is)
          \end{Verbatim}

  \end{enumerate}

\end{document}
